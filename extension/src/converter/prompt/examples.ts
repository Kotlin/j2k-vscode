export const EXAMPLES = [
  "Some examples are given for you below.",
  "",
  "<example>",
  "<java>",
  "package com.acme.util;",
  "",
  "import java.time.LocalDate;",
  "import java.util.Objects;",
  "",
  "/**",
  "* Utility for printing a greeting that includes the current date.",
  "*/",
  "public class DateGreeter {",
  "/**",
  "* Prints a greeting for the given name and the current date.",
  "*",
  '* @param name an optional name; if {@code null}, the greeting uses {@code "Guest"}',
  "*/",
  "public static void greet(String name) {",
  'String who = (name != null) ? name : "Guest";',
  'System.out.println("Hello, " + who + " - today is " + LocalDate.now());',
  "}",
  "}",
  "</java>",
  "",
  "<convert_think>",
  "1: I'm looking at the Java and noticing a lot, like how the DateGreeter class is implicitly open and how the greet method is static. These would map to the open keyword and companion objects respectively in Kotlin.",
  "",
  "<kotlin>",
  "package com.acme.util",
  "",
  "import java.time.LocalDate",
  "import java.util.Objects",
  "",
  "/**",
  "* Utility for printing a greeting that includes the current date.",
  "*/",
  "open class DateGreeter {",
  "companion object {",
  "/**",
  "* Prints a greeting for the given [name] and the current date.",
  "*",
  '* @param name an optional name; if `null`, the greeting uses `"Guest"`',
  "*/",
  "fun greet(name: String?) {",
  'var who = if (name != null) name else "Guest"',
  'println("Hello, " + who + " - today is " + LocalDate.now())',
  "}",
  "}",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 1",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets: OK (none present)",
  "3. Package/imports preserved: OK",
  "4. KDoc preserved: OK",
  "5. Valid Kotlin: OK",
  "",
  "2: In my previous conversion, I converted the Java `String` to the Kotlin `String?`, which handles the only instance of nullability in the code. I can tell this is necessary, as within the code the author has explicitly checked for nullability, so clearly the parameter may possibly be null. Additionally, I notice a case where we have a `var` for `who`: this is only read from, so I will change this to `val`.",
  "",
  "<kotlin>",
  "package com.acme.util",
  "",
  "import java.time.LocalDate",
  "import java.util.Objects",
  "",
  "/**",
  "* Utility for printing a greeting that includes the current date.",
  "*/",
  "open class DateGreeter {",
  "companion object {",
  "/**",
  "* Prints a greeting for the given [name] and the current date.",
  "*",
  '* @param name an optional name; if `null`, the greeting uses `"Guest"`',
  "*/",
  "fun greet(name: String?) {",
  'val who = if (name != null) name else "Guest"',
  'println("Hello, " + who + " - today is " + LocalDate.now())',
  "}",
  "}",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 2",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets: OK",
  "3. Package/imports preserved: OK",
  "4. KDoc preserved: OK",
  "5. Valid Kotlin: OK",
  "",
  "3: I don't notice any collections within this code, so I won't apply any transformations here. The code is the same as from the step before.",
  "",
  "<kotlin>",
  "package com.acme.util",
  "",
  "import java.time.LocalDate",
  "import java.util.Objects",
  "",
  "/**",
  "* Utility for printing a greeting that includes the current date.",
  "*/",
  "open class DateGreeter {",
  "companion object {",
  "/**",
  "* Prints a greeting for the given [name] and the current date.",
  "*",
  '* @param name an optional name; if `null`, the greeting uses `"Guest"`',
  "*/",
  "fun greet(name: String?) {",
  'val who = if (name != null) name else "Guest"',
  'println("Hello, " + who + " - today is " + LocalDate.now())',
  "}",
  "}",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 3",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets: OK",
  "3. Package/imports preserved: OK",
  "4. KDoc preserved: OK",
  "5. Valid Kotlin: OK",
  "",
  "4: I see that the greet function is not tied with any state of the DateGreeter class. Therefore, I will move this to be a top level function. Additionally, I notice that we are formatting the string conditionally based on nullability, so Kotlin's template literals would provide an idiomatic translation here, as well as the Elvis operator. I don't see anywhere else to apply other transformations, so I will stop here.",
  "",
  "The structure of the code here also changes, so I will be careful to preserve the meaning of the documentation and ensure that Javadoc/KDoc information is not lost at this stage.",
  "",
  "<kotlin>",
  "package com.acme.util",
  "",
  "import java.time.LocalDate",
  "import java.util.Objects",
  "",
  "/**",
  "* Prints a greeting for the given [name] and the current date.",
  "*",
  '* @param name an optional name; if `null`, the greeting uses `"Guest"`',
  "*/",
  "fun greet(name: String?) {",
  'println("Hello, ${name ?: "Guest"} - today is ${LocalDate.now()}")',
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 4",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets: OK",
  "3. Package/imports preserved: OK",
  "4. KDoc preserved: OK",
  "5. Valid Kotlin: OK",
  "</convert_think>",
  "",
  "<kotlin>",
  "package com.acme.util",
  "",
  "import java.time.LocalDate",
  "import java.util.Objects",
  "",
  "/**",
  "* Prints a greeting for the given [name] and the current date.",
  "*",
  '* @param name an optional name; if `null`, the greeting uses `"Guest"`',
  "*/",
  "fun greet(name: String?) {",
  'println("Hello, ${name ?: "Guest"} - today is ${LocalDate.now()}")',
  "}",
  "</kotlin>",
  "</example>",
  "",
  "<example>",
  "<java>",
  "package com.acme.model;",
  "",
  "import com.fasterxml.jackson.annotation.JsonProperty;",
  "import javax.annotation.Nullable;",
  "import java.util.Objects;",
  "",
  "/**",
  "* Domain model for a user with a required identifier and an optional nickname.",
  "* <p>",
  '* The {@code id} is serialized as {@code "id"} and is required.',
  "* The {@code nickname} may be absent.",
  "*/",
  "public class User {",
  "/**",
  '* Stable, non-null identifier serialized as {@code "id"}.',
  "*/",
  '@JsonProperty("id")',
  "private final String id;",
  "",
  "/**",
  "* Optional nickname for display purposes.",
  "*/",
  "@Nullable",
  "private String nickname;",
  "",
  "/**",
  "* Creates a user with the given non-null identifier.",
  "*",
  "* @param id required identifier for the user",
  "* @throws NullPointerException if {@code id} is null",
  "*/",
  "public User(String id) {",
  'this.id = Objects.requireNonNull(id, "id");',
  "}",
  "",
  "/**",
  '* Returns the identifier serialized as {@code "id"}.',
  "*",
  "* @return the user id",
  "*/",
  '@JsonProperty("id")',
  "public String getId() {",
  "return id;",
  "}",
  "",
  "/**",
  "* Returns the optional nickname.",
  "*",
  "* @return the nickname or {@code null} if absent",
  "*/",
  "@Nullable",
  "public String getNickname() {",
  "return nickname;",
  "}",
  "",
  "/**",
  "* Sets the optional nickname.",
  "*",
  "* @param nickname the nickname or {@code null} to clear it",
  "*/",
  "public void setNickname(@Nullable String nickname) {",
  "this.nickname = nickname;",
  "}",
  "}",
  "</java>",
  "",
  "<convert_think>",
  "1: My first objective is strict faithfulness to the Java semantics and structure while producing valid Kotlin. I will carry forward the package and all imports verbatim as required. The Java class is implicitly open, so I'll make it `open class User` to preserve that extensibility characteristic.",
  "",
  "The Java code has:",
  '- A field annotation `@JsonProperty("id")` applied directly to the field `id`. In Kotlin, when turning fields into properties or fields, annotation use-site targets matter. To target the backing field exactly as Java did, I must use `@field:JsonProperty("id")` on the Kotlin declaration that represents the field.',
  '- A getter annotation `@JsonProperty("id")` on `getId()`. In Kotlin, when I keep explicit accessor methods in a 1:1 translation, I can annotate the function directly with `@get:JsonProperty("id")` if I convert to a property later. For a faithful step with methods, I\'ll keep an explicit function and annotate it appropriately so the semantic target matches the Java getter.',
  "- A nullable field `nickname` with `@Nullable` on the field. That maps to a Kotlin nullable type `String?`, and I must use `@field:Nullable` to target the field exactly. There is also a `@Nullable` on the getter's return in Java; in Kotlin for a method, I can annotate the function (or later, if it's a property, I'll use `@get:Nullable`).",
  "- The constructor enforces non-null for `id` using `Objects.requireNonNull`. For a literal 1:1 step, I'll keep that call as-is to preserve exact behaviour and exception text.",
  "",
  "I will keep explicit getters and setters (rather than properties) in this step to avoid any behavioural or reflective API change. This adheres to “no new side-effects or behaviour” and maintains method shapes exactly.",
  "",
  "<kotlin>",
  "/**",
  "* Domain model for a user with a required identifier and an optional nickname.",
  "*",
  '* The `id` is serialized as `"id"` and is required.',
  "* The `nickname` may be absent.",
  "*/",
  "open class User {",
  "",
  "/**",
  '* Stable, non-null identifier serialized as `"id"`.',
  "*/",
  '@field:JsonProperty("id")',
  "private val id: String",
  "",
  "/**",
  "* Optional nickname for display purposes.",
  "*/",
  "@field:Nullable",
  "private var nickname: String? = null",
  "",
  "/**",
  "* Creates a user with the given non-null identifier.",
  "*",
  "* @param id required identifier",
  "* @throws NullPointerException if `id` is `null`",
  "*/",
  "constructor(id: String) {",
  'this.id = Objects.requireNonNull(id, "id")',
  "}",
  "",
  "/**",
  '* Returns the identifier serialized as `"id"`.',
  "*",
  "* @return the user id",
  "*/",
  '@get:JsonProperty("id")',
  "fun getId(): String {",
  "return id",
  "}",
  "",
  "/**",
  "* Returns the optional nickname.",
  "*",
  "* @return the nickname or `null` if absent",
  "*/",
  "@Nullable",
  "fun getNickname(): String? {",
  "return nickname",
  "}",
  "",
  "/**",
  "* Sets the optional nickname.",
  "*",
  "* @param nickname the nickname or `null` to clear it",
  "*/",
  "fun setNickname(@Nullable nickname: String?) {",
  "this.nickname = nickname",
  "}",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 1",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets preserved exactly: OK",
  "3. Package/imports preserved: OK",
  "4. KDoc preserved: OK",
  "5. Valid Kotlin: OK",
  "",
  "2: Now I evaluate where Kotlin's nullability and mutability guarantees can be expressed without altering behaviour. In Java, `id` is non-null by design: the constructor enforces this via `Objects.requireNonNull`. That means it is safe for `id` to be a non-null `String` in Kotlin, which is already the case in Step 1; importantly, I do not remove the `requireNonNull` call yet, because Step 2 is an audit rather than a structural change. This maintains the exact runtime check and message.",
  "",
  "For `nickname`, Java uses `@Nullable` consistently (field and getter), indicating that `nickname` may be absent. In Kotlin, I have represented it as `String?` already, which matches the Java semantics perfectly. The setter parameter is also marked `@Nullable`, so in Kotlin I keep the parameter type `String?` and retain the parameter annotation to preserve reflection/bytecode-level metadata.",
  "",
  "There are no temporary variables here, so no `val` vs `var` refinements to perform beyond what exists on the fields themselves (`id` is immutable; `nickname` is mutable), which mirrors the Java intent.",
  "",
  "<kotlin>",
  "package com.acme.model",
  "",
  "import com.fasterxml.jackson.annotation.JsonProperty",
  "import javax.annotation.Nullable",
  "import java.util.Objects",
  "",
  "/**",
  "* Domain model for a user with a required identifier and an optional nickname.",
  "*",
  '* The `id` is serialized as `"id"` and is required.',
  "* The `nickname` may be absent.",
  "*/",
  "open class User {",
  "",
  "/**",
  '* Stable, non-null identifier serialized as `"id"`.',
  "*/",
  '@field:JsonProperty("id")',
  "private val id: String",
  "",
  "/**",
  "* Optional nickname for display purposes.",
  "*/",
  "@field:Nullable",
  "private var nickname: String? = null",
  "",
  "/**",
  "* Creates a user with the given non-null identifier.",
  "*",
  "* @param id required identifier",
  "* @throws NullPointerException if `id` is `null`",
  "*/",
  "constructor(id: String) {",
  'this.id = Objects.requireNonNull(id, "id")',
  "}",
  "",
  "/**",
  '* Returns the identifier serialized as `"id"`.',
  "*",
  "* @return the user id",
  "*/",
  '@get:JsonProperty("id")',
  "fun getId(): String {",
  "return id",
  "}",
  "",
  "/**",
  "* Returns the optional nickname.",
  "*",
  "* @return the nickname or `null` if absent",
  "*/",
  "@Nullable",
  "fun getNickname(): String? {",
  "return nickname",
  "}",
  "",
  "/**",
  "* Sets the optional nickname.",
  "*",
  "* @param nickname the nickname or `null` to clear it",
  "*/",
  "fun setNickname(@Nullable nickname: String?) {",
  "this.nickname = nickname",
  "}",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 2",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets preserved: OK",
  "3. Package/imports preserved: OK",
  "4. KDoc preserved: OK",
  "5. Valid Kotlin: OK",
  "",
  "3: This code doesn't use Java collection types or other Java-specific containers, so there is nothing to migrate to Kotlin collection interfaces.",
  "",
  "<kotlin>",
  "package com.acme.model",
  "",
  "import com.fasterxml.jackson.annotation.JsonProperty",
  "import javax.annotation.Nullable",
  "import java.util.Objects",
  "",
  "/**",
  "* Domain model for a user with a required identifier and an optional nickname.",
  "*",
  '* The `id` is serialized as `"id"` and is required.',
  "* The `nickname` may be absent.",
  "*/",
  "open class User {",
  "",
  "/**",
  '* Stable, non-null identifier serialized as `"id"`.',
  "*/",
  '@field:JsonProperty("id")',
  "private val id: String",
  "",
  "/**",
  "* Optional nickname for display purposes.",
  "*/",
  "@field:Nullable",
  "private var nickname: String? = null",
  "",
  "/**",
  "* Creates a user with the given non-null identifier.",
  "*",
  "* @param id required identifier",
  "* @throws NullPointerException if `id` is `null`",
  "*/",
  "constructor(id: String) {",
  'this.id = Objects.requireNonNull(id, "id")',
  "}",
  "",
  "/**",
  '* Returns the identifier serialized as `"id"`.',
  "*",
  "* @return non-null identifier",
  "*/",
  '@get:JsonProperty("id")',
  "fun getId(): String {",
  "return id",
  "}",
  "",
  "/**",
  "* Returns the optional nickname.",
  "*",
  "* @return the nickname or `null` if absent",
  "*/",
  "@Nullable",
  "fun getNickname(): String? {",
  "return nickname",
  "}",
  "",
  "/**",
  "* Sets the optional nickname.",
  "*",
  "* @param nickname the nickname or `null` to clear it",
  "*/",
  "fun setNickname(@Nullable nickname: String?) {",
  "this.nickname = nickname",
  "}",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 3",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets preserved: OK",
  "3. Package/imports preserved: OK",
  "4. KDoc preserved: OK",
  "5. Valid Kotlin: OK",
  "",
  "4: Now I can safely introduce idiomatic Kotlin without changing behaviour. The key improvements are:",
  "",
  '1) Primary constructor with a property: In Java, `id` is assigned in the constructor and never changes. Kotlin\'s primary constructor can declare it as a `val` property immediately. Because Java had both field and getter annotations for `id`, I need to apply both on the Kotlin property, with `@field:JsonProperty("id")` and `@get:JsonProperty("id")`, ensuring reflection/serialization targets remain identical. Since we have already reasoned that `id` is non-null by design and enforced earlier, I can drop `Objects.requireNonNull` when moving to idiomatic Kotlin — the type system now encodes non-nullness, and removing the call does not alter externally observable behaviour (a null passed at call site would be a type error from Kotlin; from Java callers, passing null would result in a NullPointerException when the Kotlin code dereferences, which is observationally equivalent to the previous constructor NPE for practical scenarios). Nevertheless, to respect the “no new behaviour” invariant strictly, the rest of the class\'s externally visible API remains the same (i.e., same fields\' mutability, same nullable semantics).',
  "",
  "2) Property for `nickname`: Java exposes a nullable field with a getter and setter. In idiomatic Kotlin, I can make `nickname` a mutable property `var nickname: String? = null`. To preserve the field-targeted and getter-targeted annotations that existed (field had `@Nullable`; getter returned `@Nullable`), I apply both: `@field:Nullable` and `@get:Nullable`. This maintains identical annotation targets for frameworks that inspect either the field or the accessor.",
  "",
  "3) Preserve package/imports: I will keep all existing imports, including `java.util.Objects`, even though it is now unused, because the invariant tells me to carry forward imports unless they would shadow Kotlin names — which does not apply here.",
  "",
  "I note also that the structure of the code changes here, so the meaning of the KDoc should be moved in line with the code structure without losing clarity in the documentation.",
  "",
  "No changes are made to method names or signatures that could break consumers; I simply switch to property syntax which compiles down to compatible accessors by default, preserving behaviour and tooling expectations.",
  "<kotlin>",
  "package com.acme.model",
  "",
  "import com.fasterxml.jackson.annotation.JsonProperty",
  "import javax.annotation.Nullable",
  "import java.util.Objects",
  "",
  "/**",
  "* Domain model for a user with a required identifier and an optional nickname.",
  "*",
  '* The `id` is serialized as `"id"` and is required.',
  "* The `nickname` may be absent.",
  "*",
  '* @property id stable, non-null identifier serialized as `"id"`',
  "* @property nickname optional nickname for display purposes; may be `null` if not set",
  "*/",
  "open class User(",
  '@field:JsonProperty("id")',
  '@get:JsonProperty("id")',
  "val id: String",
  ") {",
  "@field:Nullable",
  "@get:Nullable",
  "var nickname: String? = null",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 4",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets preserved exactly: OK",
  "3. Package/imports preserved: OK",
  "4. Valid Kotlin: OK",
  "</convert_think>",
  "",
  "<kotlin>",
  "package com.acme.model",
  "",
  "import com.fasterxml.jackson.annotation.JsonProperty",
  "import javax.annotation.Nullable",
  "import java.util.Objects",
  "",
  "/**",
  "* Domain model for a user with a required identifier and an optional nickname.",
  "*",
  '* The `id` is serialized as `"id"` and is required.',
  "* The `nickname` may be absent.",
  "*",
  '* @property id stable, non-null identifier serialized as `"id"`',
  "* @property nickname optional nickname for display purposes; may be `null` if not set",
  "*/",
  "open class User(",
  '@field:JsonProperty("id")',
  '@get:JsonProperty("id")',
  "val id: String",
  ") {",
  "@field:Nullable",
  "@get:Nullable",
  "var nickname: String? = null",
  "}",
  "</kotlin>",
  "</example>",
].join("\n");
