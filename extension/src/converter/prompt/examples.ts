export const EXAMPLES = [
  "Some examples are given for you below.",
  "",
  "<example>",
  "<java>",
  "package com.acme.util;",
  "",
  "import java.time.LocalDate;",
  "import java.util.Objects;",
  "",
  "public class DateGreeter {",
  "    public static void greet(String name) {",
  '        String who = (name != null) ? name : "Guest";',
  '        System.out.println("Hello, " + who + " — today is " + LocalDate.now());',
  "    }",
  "}",
  "</java>",
  "",
  "<convert_think>",
  "1: I'm looking at the Java and noticing a lot, like how the DateGreeter class is implicitly open and how the greet method is static. These would map to the open keyword and companion objects respectively in Kotlin.",
  "",
  "<kotlin>",
  "package com.acme.util",
  "",
  "import java.time.LocalDate",
  "import java.util.Objects",
  "",
  "open class DateGreeter {",
  "    companion object {",
  "        fun greet(name: String?) {",
  '            var who = if (name != null) name else "Guest"',
  '            println("Hello, " + who + " — today is " + LocalDate.now())',
  "        }",
  "    }",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 1",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets: OK (none present)",
  "3. Package/imports preserved: OK",
  "4. Valid Kotlin: OK",
  "",
  "2: In my previous conversion, I converted the Java `String` to the Kotlin `String?`, which handles the only instance of nullability in the code. I can tell this is necessary, as within the code the author has explicitly checked for nullability, so clearly the parameter may possibly be null. Additionally, I notice a case where we have a `var` for `who`: this is only read from, so I will change this to `val`.",
  "",
  "<kotlin>",
  "package com.acme.util",
  "",
  "import java.time.LocalDate",
  "import java.util.Objects",
  "",
  "open class DateGreeter {",
  "    companion object {",
  "        fun greet(name: String?) {",
  '            val who = if (name != null) name else "Guest"',
  '            println("Hello, " + who + " — today is " + LocalDate.now())',
  "        }",
  "    }",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 2",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets: OK",
  "3. Package/imports preserved: OK",
  "4. Valid Kotlin: OK",
  "",
  "3: I don't notice any collections within this code, so I won't apply any transformations here. The code is the same as from the step before.",
  "",
  "<kotlin>",
  "package com.acme.util",
  "",
  "import java.time.LocalDate",
  "import java.util.Objects",
  "",
  "open class DateGreeter {",
  "    companion object {",
  "        fun greet(name: String?) {",
  '            val who = if (name != null) name else "Guest"',
  '            println("Hello, " + who + " — today is " + LocalDate.now())',
  "        }",
  "    }",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 3",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets: OK",
  "3. Package/imports preserved: OK",
  "4. Valid Kotlin: OK",
  "",
  "4: I see that the greet function is not tied with any state of the DateGreeter class. Therefore, I will move this to be a top level function. Additionally, I notice that we are formatting the string conditionally based on nullability, so Kotlin's template literals would provide an idiomatic translation here, as well as the Elvis operator. I don't see anywhere else to apply other transformations, so I will stop here.",
  "",
  "<kotlin>",
  "package com.acme.util",
  "",
  "import java.time.LocalDate",
  "import java.util.Objects",
  "",
  "fun greet(name: String?) {",
  '    println("Hello, ${name ?: "Guest"} — today is ${LocalDate.now()}")',
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 4",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets: OK",
  "3. Package/imports preserved: OK",
  "4. Valid Kotlin: OK",
  "</convert_think>",
  "",
  "<kotlin>",
  "package com.acme.util",
  "",
  "import java.time.LocalDate",
  "import java.util.Objects",
  "",
  "fun greet(name: String?) {",
  '    println("Hello, ${name ?: "Guest"} — today is ${LocalDate.now()}")',
  "}",
  "</kotlin>",
  "</example>",
  "",
  "<example>",
  "<java>",
  "package com.acme.model;",
  "",
  "import com.fasterxml.jackson.annotation.JsonProperty;",
  "import javax.annotation.Nullable;",
  "import java.util.Objects;",
  "",
  "public class User {",
  '    @JsonProperty("id")',
  "    private final String id;",
  "",
  "    @Nullable",
  "    private String nickname;",
  "",
  "    public User(String id) {",
  '        this.id = Objects.requireNonNull(id, "id");',
  "    }",
  "",
  '    @JsonProperty("id")',
  "    public String getId() {",
  "        return id;",
  "    }",
  "",
  "    @Nullable",
  "    public String getNickname() {",
  "        return nickname;",
  "    }",
  "",
  "    public void setNickname(@Nullable String nickname) {",
  "        this.nickname = nickname;",
  "    }",
  "}",
  "</java>",
  "",
  "<convert_think>",
  "1: My first objective is strict faithfulness to the Java semantics and structure while producing valid Kotlin. I will carry forward the package and all imports verbatim as required. The Java class is implicitly open, so I'll make it `open class User` to preserve that extensibility characteristic.",
  "",
  "The Java code has:",
  '- A field annotation `@JsonProperty("id")` applied directly to the field `id`. In Kotlin, when turning fields into properties or fields, annotation use-site targets matter. To target the backing field exactly as Java did, I must use `@field:JsonProperty("id")` on the Kotlin declaration that represents the field.',
  '- A getter annotation `@JsonProperty("id")` on `getId()`. In Kotlin, when I keep explicit accessor methods in a 1:1 translation, I can annotate the function directly with `@get:JsonProperty("id")` if I convert to a property later. For a faithful step with methods, I\'ll keep an explicit function and annotate it appropriately so the semantic target matches the Java getter.',
  "- A nullable field `nickname` with `@Nullable` on the field. That maps to a Kotlin nullable type `String?`, and I must use `@field:Nullable` to target the field exactly. There is also a `@Nullable` on the getter's return in Java; in Kotlin for a method, I can annotate the function (or later, if it's a property, I'll use `@get:Nullable`).",
  "- The constructor enforces non-null for `id` using `Objects.requireNonNull`. For a literal 1:1 step, I'll keep that call as-is to preserve exact behaviour and exception text.",
  "",
  "I will keep explicit getters and setters (rather than properties) in this step to avoid any behavioural or reflective API change. This adheres to “no new side-effects or behaviour” and maintains method shapes exactly.",
  "",
  "<kotlin>",
  "package com.acme.model",
  "",
  "import com.fasterxml.jackson.annotation.JsonProperty",
  "import javax.annotation.Nullable",
  "import java.util.Objects",
  "",
  "open class User {",
  "",
  '    @field:JsonProperty("id")',
  "    private val id: String",
  "",
  "    @field:Nullable",
  "    private var nickname: String? = null",
  "",
  "    constructor(id: String) {",
  '        this.id = Objects.requireNonNull(id, "id")',
  "    }",
  "",
  '    @get:JsonProperty("id")',
  "    fun getId(): String {",
  "        return id",
  "    }",
  "",
  "    @Nullable",
  "    fun getNickname(): String? {",
  "        return nickname",
  "    }",
  "",
  "    fun setNickname(@Nullable nickname: String?) {",
  "        this.nickname = nickname",
  "    }",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 1",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets preserved exactly: OK",
  "3. Package/imports preserved: OK",
  "4. Valid Kotlin: OK",
  "",
  "2: Now I evaluate where Kotlin's nullability and mutability guarantees can be expressed without altering behaviour. In Java, `id` is non-null by design: the constructor enforces this via `Objects.requireNonNull`. That means it is safe for `id` to be a non-null `String` in Kotlin, which is already the case in Step 1; importantly, I do not remove the `requireNonNull` call yet, because Step 2 is an audit rather than a structural change. This maintains the exact runtime check and message.",
  "",
  "For `nickname`, Java uses `@Nullable` consistently (field and getter), indicating that `nickname` may be absent. In Kotlin, I have represented it as `String?` already, which matches the Java semantics perfectly. The setter parameter is also marked `@Nullable`, so in Kotlin I keep the parameter type `String?` and retain the parameter annotation to preserve reflection/bytecode-level metadata.",
  "",
  "There are no temporary variables here, so no `val` vs `var` refinements to perform beyond what exists on the fields themselves (`id` is immutable; `nickname` is mutable), which mirrors the Java intent.",
  "",
  "<kotlin>",
  "package com.acme.model",
  "",
  "import com.fasterxml.jackson.annotation.JsonProperty",
  "import javax.annotation.Nullable",
  "import java.util.Objects",
  "",
  "open class User {",
  "",
  '    @field:JsonProperty("id")',
  "    private val id: String",
  "",
  "    @field:Nullable",
  "    private var nickname: String? = null",
  "",
  "    constructor(id: String) {",
  '        this.id = Objects.requireNonNull(id, "id")',
  "    }",
  "",
  '    @get:JsonProperty("id")',
  "    fun getId(): String {",
  "        return id",
  "    }",
  "",
  "    @Nullable",
  "    fun getNickname(): String? {",
  "        return nickname",
  "    }",
  "",
  "    fun setNickname(@Nullable nickname: String?) {",
  "        this.nickname = nickname",
  "    }",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 2",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets preserved: OK",
  "3. Package/imports preserved: OK",
  "4. Valid Kotlin: OK",
  "",
  "3: This code doesn't use Java collection types or other Java-specific containers, so there is nothing to migrate to Kotlin collection interfaces.",
  "",
  "<kotlin>",
  "package com.acme.model",
  "",
  "import com.fasterxml.jackson.annotation.JsonProperty",
  "import javax.annotation.Nullable",
  "import java.util.Objects",
  "",
  "open class User {",
  "",
  '    @field:JsonProperty("id")',
  "    private val id: String",
  "",
  "    @field:Nullable",
  "    private var nickname: String? = null",
  "",
  "    constructor(id: String) {",
  '        this.id = Objects.requireNonNull(id, "id")',
  "    }",
  "",
  '    @get:JsonProperty("id")',
  "    fun getId(): String {",
  "        return id",
  "    }",
  "",
  "    @Nullable",
  "    fun getNickname(): String? {",
  "        return nickname",
  "    }",
  "",
  "    fun setNickname(@Nullable nickname: String?) {",
  "        this.nickname = nickname",
  "    }",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 3",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets preserved: OK",
  "3. Package/imports preserved: OK",
  "4. Valid Kotlin: OK",
  "",
  "4: Now I can safely introduce idiomatic Kotlin without changing behaviour. The key improvements are:",
  "",
  '1) Primary constructor with a property: In Java, `id` is assigned in the constructor and never changes. Kotlin\'s primary constructor can declare it as a `val` property immediately. Because Java had both field and getter annotations for `id`, I need to apply both on the Kotlin property, with `@field:JsonProperty("id")` and `@get:JsonProperty("id")`, ensuring reflection/serialization targets remain identical. Since we have already reasoned that `id` is non-null by design and enforced earlier, I can drop `Objects.requireNonNull` when moving to idiomatic Kotlin — the type system now encodes non-nullness, and removing the call does not alter externally observable behaviour (a null passed at call site would be a type error from Kotlin; from Java callers, passing null would result in a NullPointerException when the Kotlin code dereferences, which is observationally equivalent to the previous constructor NPE for practical scenarios). Nevertheless, to respect the “no new behaviour” invariant strictly, the rest of the class\'s externally visible API remains the same (i.e., same fields\' mutability, same nullable semantics).',
  "",
  "2) Property for `nickname`: Java exposes a nullable field with a getter and setter. In idiomatic Kotlin, I can make `nickname` a mutable property `var nickname: String? = null`. To preserve the field-targeted and getter-targeted annotations that existed (field had `@Nullable`; getter returned `@Nullable`), I apply both: `@field:Nullable` and `@get:Nullable`. This maintains identical annotation targets for frameworks that inspect either the field or the accessor.",
  "",
  "3) Preserve package/imports: I will keep all existing imports, including `java.util.Objects`, even though it is now unused, because the invariant tells me to carry forward imports unless they would shadow Kotlin names — which does not apply here.",
  "",
  "No changes are made to method names or signatures that could break consumers; I simply switch to property syntax which compiles down to compatible accessors by default, preserving behaviour and tooling expectations.",
  "<kotlin>",
  "package com.acme.model",
  "",
  "import com.fasterxml.jackson.annotation.JsonProperty",
  "import javax.annotation.Nullable",
  "import java.util.Objects",
  "",
  "open class User(",
  '    @field:JsonProperty("id")',
  '    @get:JsonProperty("id")',
  "    val id: String",
  ") {",
  "    @field:Nullable",
  "    @get:Nullable",
  "    var nickname: String? = null",
  "}",
  "</kotlin>",
  "",
  "Invariants check after Step 4",
  "1. No new side-effects/behaviour: OK",
  "2. Annotations/targets preserved exactly: OK",
  "3. Package/imports preserved: OK",
  "4. Valid Kotlin: OK",
  "</convert_think>",
  "",
  "<kotlin>",
  "package com.acme.model",
  "",
  "import com.fasterxml.jackson.annotation.JsonProperty",
  "import javax.annotation.Nullable",
  "import java.util.Objects",
  "",
  "open class User(",
  '    @field:JsonProperty("id")',
  '    @get:JsonProperty("id")',
  "    val id: String",
  ") {",
  "    @field:Nullable",
  "    @get:Nullable",
  "    var nickname: String? = null",
  "}",
  "</kotlin>",
  "</example>",
].join("\n");
